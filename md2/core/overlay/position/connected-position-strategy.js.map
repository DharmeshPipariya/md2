{"version":3,"sources":["core/overlay/position/connected-position-strategy.ts"],"names":[],"mappings":"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","file":"core/overlay/position/connected-position-strategy.js","sourcesContent":["import {PositionStrategy} from './position-strategy';\r\nimport {ElementRef} from '@angular/core';\r\nimport {ViewportRuler} from './viewport-ruler';\r\nimport {applyCssTransform} from '../../style/apply-transform';\r\nimport {\r\n    ConnectionPositionPair,\r\n    OriginConnectionPosition,\r\n    OverlayConnectionPosition\r\n} from './connected-position';\r\n\r\n\r\n/**\r\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\r\n * implict position relative some origin element. The relative position is defined in terms of\r\n * a point on the origin element that is connected to a point on the overlay element. For example,\r\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\r\n * of the overlay.\r\n */\r\nexport class ConnectedPositionStrategy implements PositionStrategy {\r\n  // TODO(jelbourn): set RTL to the actual value from the app.\r\n  /** Whether the we're dealing with an RTL context */\r\n  _isRtl: boolean = false;\r\n\r\n  /** Ordered list of preferred positions, from most to least desirable. */\r\n  _preferredPositions: ConnectionPositionPair[] = [];\r\n\r\n  /** The origin element against which the overlay will be positioned. */\r\n  private _origin: HTMLElement;\r\n\r\n\r\n  constructor(\r\n      private _connectedTo: ElementRef,\r\n      private _originPos: OriginConnectionPosition,\r\n      private _overlayPos: OverlayConnectionPosition,\r\n      private _viewportRuler: ViewportRuler) {\r\n    this._origin = this._connectedTo.nativeElement;\r\n    this.withFallbackPosition(_originPos, _overlayPos);\r\n  }\r\n\r\n  get positions() {\r\n    return this._preferredPositions;\r\n  }\r\n\r\n  /**\r\n   * Updates the position of the overlay element, using whichever preferred position relative\r\n   * to the origin fits on-screen.\r\n   * TODO: internal\r\n   */\r\n  apply(element: HTMLElement): Promise<void> {\r\n    // We need the bounding rects for the origin and the overlay to determine how to position\r\n    // the overlay relative to the origin.\r\n    const originRect = this._origin.getBoundingClientRect();\r\n    const overlayRect = element.getBoundingClientRect();\r\n\r\n    // We use the viewport rect to determine whether a position would go off-screen.\r\n    const viewportRect = this._viewportRuler.getViewportRect();\r\n    let firstOverlayPoint: Point = null;\r\n\r\n    // We want to place the overlay in the first of the preferred positions such that the\r\n    // overlay fits on-screen.\r\n    for (let pos of this._preferredPositions) {\r\n      // Get the (x, y) point of connection on the origin, and then use that to get the\r\n      // (top, left) coordinate for the overlay at `pos`.\r\n      let originPoint = this._getOriginConnectionPoint(originRect, pos);\r\n      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\r\n      firstOverlayPoint = firstOverlayPoint || overlayPoint;\r\n\r\n      // If the overlay in the calculated position fits on-screen, put it there and we're done.\r\n      if (this._willOverlayFitWithinViewport(overlayPoint, overlayRect, viewportRect)) {\r\n        this._setElementPosition(element, overlayPoint);\r\n        return Promise.resolve(null);\r\n      }\r\n    }\r\n\r\n    // TODO(jelbourn): fallback behavior for when none of the preferred positions fit on-screen.\r\n    // For now, just stick it in the first position and let it go off-screen.\r\n    this._setElementPosition(element, firstOverlayPoint);\r\n    return Promise.resolve(null);\r\n  }\r\n\r\n  withFallbackPosition(\r\n      originPos: OriginConnectionPosition,\r\n      overlayPos: OverlayConnectionPosition): this {\r\n    this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\r\n    return this;\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\r\n   * @param rect\r\n   */\r\n  private _getStartX(rect: ClientRect): number {\r\n    return this._isRtl ? rect.right : rect.left;\r\n  }\r\n\r\n  /**\r\n   * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\r\n   * @param rect\r\n   */\r\n  private _getEndX(rect: ClientRect): number {\r\n    return this._isRtl ? rect.left : rect.right;\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\r\n   * @param originRect\r\n   * @param pos\r\n   */\r\n  private _getOriginConnectionPoint(originRect: ClientRect, pos: ConnectionPositionPair): Point {\r\n    const originStartX = this._getStartX(originRect);\r\n    const originEndX = this._getEndX(originRect);\r\n\r\n    let x: number;\r\n    if (pos.originX == 'center') {\r\n      x = originStartX + (originRect.width / 2);\r\n    } else {\r\n      x = pos.originX == 'start' ? originStartX : originEndX;\r\n    }\r\n\r\n    let y: number;\r\n    if (pos.originY == 'center') {\r\n      y = originRect.top + (originRect.height / 2);\r\n    } else {\r\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\r\n    }\r\n\r\n    return {x, y};\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\r\n   * origin point to which the overlay should be connected.\r\n   * @param originPoint\r\n   * @param overlayRect\r\n   * @param pos\r\n   */\r\n  private _getOverlayPoint(\r\n      originPoint: Point,\r\n      overlayRect: ClientRect,\r\n      pos: ConnectionPositionPair): Point {\r\n    // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\r\n    // relative to the origin point.\r\n    let overlayStartX: number;\r\n    if (pos.overlayX == 'center') {\r\n      overlayStartX = -overlayRect.width / 2;\r\n    } else {\r\n      overlayStartX = pos.overlayX == 'start' ? 0 : -overlayRect.width;\r\n    }\r\n\r\n    let overlayStartY: number;\r\n    if (pos.overlayY == 'center') {\r\n      overlayStartY = -overlayRect.height / 2;\r\n    } else {\r\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\r\n    }\r\n\r\n    return {\r\n      x: originPoint.x + overlayStartX,\r\n      y: originPoint.y + overlayStartY\r\n    };\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets whether the overlay positioned at the given point will fit on-screen.\r\n   * @param overlayPoint The top-left coordinate of the overlay.\r\n   * @param overlayRect Bounding rect of the overlay, used to get its size.\r\n   * @param viewportRect The bounding viewport.\r\n   */\r\n  private _willOverlayFitWithinViewport(\r\n      overlayPoint: Point,\r\n      overlayRect: ClientRect,\r\n      viewportRect: ClientRect): boolean {\r\n\r\n    // TODO(jelbourn): probably also want some space between overlay edge and viewport edge.\r\n    return overlayPoint.x >= viewportRect.left &&\r\n        overlayPoint.x + overlayRect.width <= viewportRect.right &&\r\n        overlayPoint.y >= viewportRect.top &&\r\n        overlayPoint.y + overlayRect.height <= viewportRect.bottom;\r\n  }\r\n\r\n\r\n  /**\r\n   * Physically positions the overlay element to the given coordinate.\r\n   * @param element\r\n   * @param overlayPoint\r\n   */\r\n  private _setElementPosition(element: HTMLElement, overlayPoint: Point) {\r\n    let scrollPos = this._viewportRuler.getViewportScrollPosition();\r\n\r\n    let x = overlayPoint.x + scrollPos.left;\r\n    let y = overlayPoint.y + scrollPos.top;\r\n\r\n    // TODO(jelbourn): we don't want to always overwrite the transform property here,\r\n    // because it will need to be used for animations.\r\n    applyCssTransform(element, `translateX(${x}px) translateY(${y}px)`);\r\n  }\r\n}\r\n\r\n\r\n/** A simple (x, y) coordinate. */\r\ntype Point = {x: number, y: number};\r\n\r\n\r\n"],"sourceRoot":"/source/"}